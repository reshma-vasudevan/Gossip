Final report

1. Structure
1.1 Architecture
i. Logical structure:
    classes :
    Message classes to handle each type of API message
    MessageStorage class to handle the cache for announced messages and subscribers
    ServerThread and client threads, inheriting from thread, handle creation of API/P2P server and their received connections
    AnnounceMessageHandler class, inheriting from thread, to act on received announce messages
    NotifThread class, inheriting from thread, to propagate notification messages

ii. Process Architecture:
- threading: built-in threading module
API process architecture:
                            queue, connections
            APIServerThread    ----------->       AnnounceMessageHandler
           /         \                              /             \
          /           \                            /               \
         /             \                          /                 \
APIClientThread1 ... APIClientThreadn       NotifThread1  .....   NotifThreadm

P2P process architecture:

            P2PServerThread
           /         \
          /           \
         /             \
P2PClientThread1 ... P2PClientThreadn


Main Server thread is started which creates and holds two server thread, one for API connections and one for P2P connections.
When client connection is received, new APIClientThread is spawned for API connections and received messages are processed. When a P2P connection is received, a corresponding P2PClientThread is spawned which then handles the request.
For API Connections another thread, AnnounceMessageHandler, is started from main to wait on queue of announced messages and spawn new threads
for message spreading.

Shared resources between server and messagehandler threads : MessageStorage, announce_message_queue(queue), connections(dict)

On receiving message in a client connection, it is processed and appropriate action is take in the client thread.
If announce message received, it is added to the message queue. messagehandler retrieves the item from queue
and spawns threads to send Notification messages to each of the subscribers

Each subscriber thread checks if connection already exists for the subscriber and reuses it to send message. If not,
new connection is created and message is sent.

1.2. Peer-to-peer protocol:
i. Message format:
- Header: each message in the p2p protocol starts with a header of the following form (same as in the API protocol):
+----------------+----------------+
| size (2 bytes) | type (2 bytes) |
+----------------+----------------+

- Pull (type: 504): a node should be able to ask other peers for IDs. It sends it's own IP address and port.
+-----------------------------------+
|                                   |
| ip (ipv4: 4 bytes, ipv6: 16 bytes)|
|                                   |
+-----------------------------------+
|          port (2 bytes)           |
+-----------------------------------+

- Response (type: 505): a node should to be able to answer a pull request, sending it's IDs to the receiver.
+-----------------------------------+
|                                   |
|               IDs                 |
|                                   |
+-----------------------------------+

- Push (type: 506): a node should be able to push its IDs to a random peer, also included is it's own IP and port.
+-----------------------------------+
|                                   |
| ip (ipv4: 4 bytes, ipv6: 16 bytes)|
|                                   |
+-----------------------------------+
|          port (2 bytes)           |
+-----------------------------------+
|                                   |
|               IDs                 |
|                                   |
+-----------------------------------+

- Send_Content (type: 507): a node should be able to send arbitrary binary content to another node.
+-----------------------------------+
|                                   |
|              content              |
|                                   |
+-----------------------------------+

Format for IDs:
IDs should start with the total number of IDs included:
+-----------------------------------+
|    total ID count (2 bytes)       |
+-----------------------------------+
And continue with that number of the following:
+-----------------------------------+
|        counter (2 bytes)          |
+-----------------------------------+
|                                   |
| ip (ipv4: 4 bytes, ipv6: 16 bytes)|
|                                   |
+-----------------------------------+
|          port (2 bytes)           |
+-----------------------------------+
Counter simply counts from 0 up to the number specified in the total ID count

ii. Reasoning:
We have chosen to go for a push-pull approach. Thus we need three p2p-messages: push, pull and a response to the pull request.
iii. Exception handling:
If the IDs of any of the messages are corrupted, i.e. not in the specified format, the message is simply discarded.
If a connection breaks unexpectedly, any data read from the connection is discarded.
responseTimeout, if the client takes too long to respond, connection is closed.
messageLengthExceeded, when the received message is longer than max expected length of 64K, the message is discarded.

2. Software Documentation
i. Building/Running:
ii. How to install and run the software
iii. Known issues

3. Future work:

4. Workload Distribution:
i. Nicolas: Structure for the program to run (server/request handler thread classes, main), config parsing, exceptions,
            P2P protocol design, logging
ii. Reshma: API conformity, storage for messages, message and messagestorage classes and related tests,
            Process architecture design and implementation using thread classes as described,
            API workflow with sample clients operational

5.Effort spent:
i. Nicolas: Config parsing ~3h, exceptions ~1h, structure for the program to run ~6h, P2P protocol design ~3h, logging ~2h
ii. Reshma: API conformity ~3h, design for messages and storage ~2h, defining classes and tests ~4h, process arch design ~5h,
            process arch impl. ~4h, ensuring working API workflow ~1h
